#!/usr/bin/env python3
"""
Compatibility test runner for mermaid-rs vs mermaid-py.

This script loads test scenarios from YAML files and compares the Mermaid
output generated by mermaid-py (reference) against mermaid-rs (implementation).
"""

import os
import re
import subprocess
import sys
from pathlib import Path
from typing import Any

import yaml

# mermaid-py imports
from mermaid.flowchart import FlowChart, Node, Link as FlowLink
from mermaid.piechart import PieChart
from mermaid.sequence import SequenceDiagram, Actor as SeqActor, Link as SeqLink, ArrowTypes
from mermaid.statediagram import StateDiagram, State, Transition, Start, End
from mermaid.erdiagram import ERDiagram, Entity, Link as ERLink
from mermaid.userjourney import UserJourney, Section, Task
from mermaid.mindmap import Mindmap, Level


SCENARIOS_DIR = Path(__file__).parent / "scenarios"
OUTPUT_DIR = Path(__file__).parent / "output"
MERMAID_RS_BIN = Path(__file__).parent.parent / "target" / "release" / "mermaid-rs"


def normalize_output(text: str) -> str:
    """Normalize mermaid output for comparison.

    - Strip leading/trailing whitespace
    - Normalize line endings
    - Remove frontmatter (---...---)
    - Collapse multiple blank lines
    - Normalize tabs to 4 spaces (both produce valid mermaid, just different style)
    """
    # Normalize line endings
    text = text.replace('\r\n', '\n')

    # Remove frontmatter if present
    frontmatter_pattern = r'^---\n.*?\n---\n?'
    text = re.sub(frontmatter_pattern, '', text, flags=re.DOTALL)

    # Normalize tabs to 4 spaces for comparison
    text = text.replace('\t', '    ')

    # Strip and normalize whitespace
    lines = [line.rstrip() for line in text.strip().split('\n')]

    # Remove empty lines at start/end and collapse multiple empty lines
    result = []
    prev_empty = False
    for line in lines:
        is_empty = not line.strip()
        if is_empty:
            if not prev_empty:
                result.append('')
            prev_empty = True
        else:
            result.append(line)
            prev_empty = False

    return '\n'.join(result).strip()


def extract_diagram_body(text: str) -> str:
    """Extract just the diagram body (after the diagram type declaration)."""
    text = normalize_output(text)
    # Find the diagram type line and return everything after it
    lines = text.split('\n')
    # Return all lines (the diagram type declaration is important for comparison)
    return '\n'.join(lines)


def load_scenario(path: Path) -> dict[str, Any]:
    """Load a test scenario from a YAML file."""
    with open(path) as f:
        return yaml.safe_load(f)


def generate_mermaid_py(scenario: dict[str, Any]) -> str:
    """Generate Mermaid output using mermaid-py."""
    diagram_type = scenario['type']
    title = scenario.get('title', 'Untitled')

    if diagram_type == 'pie':
        data = {item['label']: item['value'] for item in scenario['data']}
        show_data = scenario.get('show_data', False)
        chart = PieChart(title=title, data=data, show_data=show_data)
        return chart.script

    elif diagram_type == 'flowchart':
        direction = scenario.get('direction', 'TD')
        nodes = [Node(n['id'], n.get('label', n['id'])) for n in scenario.get('nodes', [])]
        links = []
        for link in scenario.get('links', []):
            l = FlowLink(
                Node(link['from']),
                Node(link['to']),
                message=link.get('label', '')
            )
            links.append(l)
        chart = FlowChart(title=title, nodes=nodes, links=links, orientation=direction)
        return chart.script

    elif diagram_type == 'sequence':
        # SequenceDiagram takes a single 'elements' list containing actors and links
        elements = []
        # Add actors first
        for p in scenario.get('participants', []):
            elements.append(SeqActor(p['id']))
        # Add message links
        for m in scenario.get('messages', []):
            elements.append(SeqLink(
                SeqActor(m['from']),
                SeqActor(m['to']),
                type_=ArrowTypes.SOLID_ARROW,
                message=m['text']
            ))
        diagram = SequenceDiagram(title=title, elements=elements)
        return diagram.script

    elif diagram_type == 'state':
        states = [State(s['id']) for s in scenario.get('states', [])]
        transitions = []
        for t in scenario.get('transitions', []):
            from_state = t['from']
            to_state = t['to']

            # Handle special start/end states
            if from_state == '[*]':
                from_obj = Start()
            else:
                from_obj = State(from_state)

            if to_state == '[*]':
                to_obj = End()
            else:
                to_obj = State(to_state)

            trans = Transition(
                from_obj,
                to_obj,
                label=t.get('label', '')
            )
            transitions.append(trans)
        diagram = StateDiagram(title=title, states=states, transitions=transitions)
        return diagram.script

    elif diagram_type == 'er':
        entities = [Entity(e['name']) for e in scenario.get('entities', [])]
        links = []
        for r in scenario.get('relationships', []):
            link = ERLink(
                Entity(r['from']),
                Entity(r['to']),
                origin_cardinality=r.get('from_cardinality', 'exactly-one'),
                end_cardinality=r.get('to_cardinality', 'zero-or-more'),
                label=r.get('label', '')
            )
            links.append(link)
        diagram = ERDiagram(title=title, entities=entities, links=links)
        return diagram.script

    elif diagram_type == 'journey':
        sections = []
        for s in scenario.get('sections', []):
            tasks = [Task(t['name'], t['score'], []) for t in s.get('tasks', [])]
            section = Section(s['name'], tasks)
            sections.append(section)
        diagram = UserJourney(title=title, sections=sections)
        return diagram.script

    elif diagram_type == 'mindmap':
        def build_level(data: dict) -> Level:
            children = [build_level(child) for child in data.get('children', [])]
            return Level(data['text'], children=children if children else None)

        root_data = scenario['root']
        root_level = build_level(root_data)
        # Mindmap takes 'levels' as the children of the root (title is the root)
        # Actually looking at the API, title IS the root text, and levels are the children
        diagram = Mindmap(title=root_data['text'], levels=root_level.children)
        return diagram.script

    else:
        raise ValueError(f"Unknown diagram type: {diagram_type}")


def generate_mermaid_rs(scenario: dict[str, Any], scenario_path: Path) -> str:
    """Generate Mermaid output using mermaid-rs CLI."""
    diagram_type = scenario['type']

    # Map scenario types to CLI subcommands
    type_map = {
        'pie': 'pie',
        'flowchart': 'flowchart',
        'sequence': 'sequence',
        'state': 'state',
        'er': 'er',
        'journey': 'journey',
        'mindmap': 'mindmap',
    }

    subcommand = type_map.get(diagram_type)
    if not subcommand:
        raise ValueError(f"Unknown diagram type: {diagram_type}")

    # Run mermaid-rs with the input file, output mermaid format to stdout
    cmd = [str(MERMAID_RS_BIN), subcommand, '--input', str(scenario_path), '-f', 'mermaid', '--stdout']

    result = subprocess.run(cmd, capture_output=True, text=True)

    if result.returncode != 0:
        print(f"  mermaid-rs stderr: {result.stderr}", file=sys.stderr)
        raise RuntimeError(f"mermaid-rs failed: {result.stderr}")

    return result.stdout


def compare_outputs(py_output: str, rs_output: str) -> tuple[bool, str]:
    """Compare mermaid-py and mermaid-rs outputs.

    Returns (match, diff_message).
    """
    py_normalized = extract_diagram_body(py_output)
    rs_normalized = extract_diagram_body(rs_output)

    if py_normalized == rs_normalized:
        return True, ""

    # Generate diff for debugging
    py_lines = py_normalized.split('\n')
    rs_lines = rs_normalized.split('\n')

    diff_lines = []
    max_lines = max(len(py_lines), len(rs_lines))

    for i in range(max_lines):
        py_line = py_lines[i] if i < len(py_lines) else '<missing>'
        rs_line = rs_lines[i] if i < len(rs_lines) else '<missing>'

        if py_line != rs_line:
            diff_lines.append(f"  Line {i+1}:")
            diff_lines.append(f"    py: {repr(py_line)}")
            diff_lines.append(f"    rs: {repr(rs_line)}")

    return False, '\n'.join(diff_lines)


def run_tests() -> tuple[int, int]:
    """Run all compatibility tests.

    Returns (passed, failed) counts.
    """
    OUTPUT_DIR.mkdir(exist_ok=True)

    scenarios = sorted(SCENARIOS_DIR.glob('*.yaml'))

    if not scenarios:
        print("No test scenarios found!")
        return 0, 0

    passed = 0
    failed = 0

    print(f"Running {len(scenarios)} compatibility tests...\n")

    for scenario_path in scenarios:
        name = scenario_path.stem
        print(f"Testing {name}...", end=' ')

        try:
            scenario = load_scenario(scenario_path)

            # Generate outputs
            py_output = generate_mermaid_py(scenario)
            rs_output = generate_mermaid_rs(scenario, scenario_path)

            # Save outputs for inspection
            (OUTPUT_DIR / f"{name}.py.mmd").write_text(py_output)
            (OUTPUT_DIR / f"{name}.rs.mmd").write_text(rs_output)

            # Compare
            match, diff = compare_outputs(py_output, rs_output)

            if match:
                print("PASS")
                passed += 1
            else:
                print("FAIL")
                print(f"  Differences found:\n{diff}")
                failed += 1

        except Exception as e:
            print(f"ERROR: {e}")
            failed += 1

    print()
    print(f"Results: {passed} passed, {failed} failed")

    return passed, failed


def main():
    if not MERMAID_RS_BIN.exists():
        print(f"Error: mermaid-rs binary not found at {MERMAID_RS_BIN}")
        print("Run 'otto build' first to build the release binary.")
        sys.exit(1)

    passed, failed = run_tests()
    sys.exit(0 if failed == 0 else 1)


if __name__ == '__main__':
    main()
